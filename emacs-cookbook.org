#+TITLE: Emacs实践笔记
#+AUTHOR: aborn
#+DATE: 2018-06-15 20:29
#+EMAIL: aborn.jiang@gmail.com
#+LANGUAGE: zh
#+LATEX_HEADER: \usepackage{xeCJK}

#+SETUPFILE: ~/github/org-html-themes/setup/theme-readtheorg.setup

-----
* 基本数据类型
** Lisp的数据类型
  Lisp的对象至少属于一种数据类型。Emacs里最基础的数据类型称之为原始类型（primitive type）,
  这些原始类型包括整型、浮点、cons、符号(symbol)、字符串、数组、哈希表（hash-table）、subr、
  二进制编码函数(byte-code function)，再加上一些特殊的类型，如buffer。同时，每种原始类型都
  有一个对应的函数去校验对象是否属于其类型。
** 符号类型(Symbols)
  符号类型是一种有唯一标识的命名对象。它常用于变量及函数名。判断一个对象是否为符号类型用
  *symbolp object* 方法。
*** 符号类型的组成
   每个符号类型由四部分组成，每部分称之为单元，每个单元指向其他对象。
**** 名字
    即符号标识，获取符号标识名的函数为(symbol-name symbol)
**** 变量值
    当标识对象作为变量时的值
**** 函数
    标识函数定义，函数单元可保存另一个标识对象、或者keymap、或者一个键盘宏
**** 属性列表
    标识对象的属性列表(plist)，获取属性列表函数为(symbol-plist symbol)
    注意，其中 *名字* 为字符串类型，不可改变，其他三个组成部分可被赋值为任意lisp对象。
    其值为属性列表(plist)。一个以冒号开头的符号类型称之为keyword symbol，它常用于常量类型。
*** 定义符号类型
   定义符号类型对象是一种特殊的lisp表达式，它表示将标识类型用于特殊用途。
**** defvar 和 devconst
    它们是一种特殊表达式（Special Forms），它定义一个标识作为全局变量。实际应用中往往使用
    *setq*，它可以将任意变量值绑定到标识对象。
**** defun
    用于定义函数，它的作用是创建一个lambda表达式，并将其存储在标识对象的函数单元里。
**** defmacro
    定义标识符为宏，创建一个宏对象并前对象保存在函数单元里。
*** 符号类型操作函数
   常见的与标识类型相关的函数有 *make-symbol* 和 *intern*
**** make-symbol
    #+BEGIN_SRC emacs-lisp
    make-symbol name
    #+END_SRC
    这个函数返回一个新的标识对象，它的名字是 *name* (必须为字符串)
**** intern
    #+BEGIN_SRC emacs-lisp
    intern name &optional obarray
    #+END_SRC
    这个函数返回一个被绑定的名字为 *name* 的标识对象。如果标识符不在变量 *obarray* 对应的
    对象数组(obarray）里，创建一个新的，并加入到对象对象数组里。当无obarray参数时，采用全局的
    对象数组obarray。
*** 标识符属性
   标识符属性记录了标识符的额外信息，下面的函数是对标签符属性进行操作：
**** get symbol property
    获取标识符属性为property的属性值，属性不存在返回nil
**** put symbol property value
    设置标识符属性property的值为value，如果之前存在相同的属性名，其值将被覆盖。这个函数返回
    value。下面是一些例子：
    #+BEGIN_SRC emacs-lisp
    (put 'fly 'verb 'transitive)              ;; ⇒'transitive
    (put 'fly 'noun '(a buzzing little bug))  ;; ⇒ (a buzzing little bug)
    (get 'fly 'verb)       ;; ⇒ transitive
    (symbol-plist 'fly)    ;; ⇒ (verb transitive noun (a buzzing little bug))
    #+END_SRC
**** 标准标识符属性
    下面列的一些标准标识符属性用于emacs的特殊用途
***** :advertised-binding
     用于函数的key的绑定
***** interactive-form
     用于交互函数，不要手工设置它，通过 *interactive* 特殊表达式来设置它
***** disabled
     如果不为nil，对应的函数不能作为命令
***** theme-face
     用于主题设置
** 列表
  列表是由零个或者多个元素组成的序列，列表中的每个元素都可由任意的对象组成。
*** 关联列表alist (Association Lists)
   关联列表是一种特殊的列表，它的每个元素都是一个点对构成，如下示例:
   #+BEGIN_SRC emacs-lisp
   (setq alist-of-colors
      '((rose . red) (lily . white) (buttercup . yellow)))
   #+END_SRC
   关联列表可以用来记录key-value这样的map结构；对每个元素做car操作拿到key，做cdr操作即拿到
   相关系的value。
**** 关联列表操作
    + (assoc key alist) 获取列表第一个key所关联的值；下面是一个例子：
    #+BEGIN_SRC emacs-lisp
    ELISP> (assoc 'rose alist-of-colors)
    (rose . red)
    #+END_SRC
    注意：这里用得比较是equal函数，如想用eq函数，请采用(assq key alist)这个函数
    + (rassoc value alist) 获取列表第一个value为 *value* 所关联的值；
    + (assoc-default key alist) 获取列表中第一个key为 *key* 的value；
    #+BEGIN_SRC emacs-lisp
    ELISP> (assoc-default 'rose alist-of-colors)
    red
    #+END_SRC
*** 属性列表plist (Property Lists)
   属性列表是由成对元素（paired elements）组成的列表，每个元素对关联着一个属性的名及其
   对应属性值。下面是一个例子：
   #+BEGIN_SRC emacs-lisp
    (pine cones numbers (1 2 3) color "blue")
   #+END_SRC
   这里pine关联其值为cons，numbers关联其值为(1 2 3)，一般每个元素对的关联值是由symbol类型
   组成的。
**** 属性列表的操作
    + (plist-get plist property) 返回属性列表中属性名为property的属性值:
    #+BEGIN_SRC emacs-lisp
    ELISP> (setq pl '(pine cones numbers (1 2 3) color "blue"))
    (pine cones numbers
          (1 2 3)
          color "blue")
    ELISP> (plist-get pl 'pine)
    cones
    ELISP> (plist-get pl 'numbers)
    (1 2 3)
    #+END_SRC
    + (plist-member plist property) 如果属性列表plist中含有属性property，则返回non-nil。
    + (plist-put plist property value) 保存属性property及值value的属性对
    #+BEGIN_SRC emacs-lisp
    (setq my-plist '(bar t foo 4))                    ;; => (bar t foo 4)
    (setq my-plist (plist-put my-plist 'foo 69))      ;; => (bar t foo 69)
    (setq my-plist (plist-put my-plist 'quux '(a)))   ;; => (bar t foo 69 quux (a))
    #+END_SRC
*** 对列表进行排序
   对列表进行排序可以采用sort这个函数 *(sort list predicate)* 。不过这个函数是有副作用的，
   这个函数调用后会改变原有list的结构。第三个参数predicate传入的是一个比较函数，它接收两个参数。
   如果是想递增排序，当第一个参数小于第二个参数时返回non-nil，否则返回nil。注意这个sort函数
   对list的排序，始终保持car部分不变。下面是一个例子：
   #+BEGIN_SRC emacs-lisp
    ELISP> (setq nums '(1 3 2 6 5 4 0))
    (1 3 2 6 5 4 0)
    ELISP> (sort nums '<)
    (0 1 2 3 4 5 6)
    ELISP> nums
    (1 2 3 4 5 6)
   #+END_SRC
   注意这里的nums排序后，的car与原来list的car是一样的。所以一般采用重新赋值的方式
   *(setq nums (sort nums ’<))*
* 求值
** 求值
  Lisp解释器会对表达式进行求值操作，也可以手工调用求值方法 *eval* 。Lisp解释器通常先读取Lisp
  表达式，然后对表达式进行求值。其实，读取和求值是两个相互独立的过程，它们也可以进行单独操作。
** 表达式类型
  表达式是一种用于求值的lisp对象, Emacs有三种不同的求值表达式类型：标识符(Symbols)、列表和其
  他类型。下面从其他类型开始介绍。
*** 自解释表达式
   自解释类型，其意思很明确是自己对自己求值，例如25自解释成25，自符串"foo"自解释成"foo"。
*** 标识符类型
   当标识符类型被求值，它将被当成变量使用，求值的结果就是变量的值。如果变量没有值，Lisp解释器会
   抛出一个错误提示。
   #+BEGIN_SRC emacs-lisp
   (setq a 123)   ;; ⇒ 123
   (eval 'a)      ;; ⇒ 123
   a              ;; ⇒ 123
   #+END_SRC
*** 自动载入(Autoloading)
   自动载入的特性允许函数或者宏还没有载入到Emacs中前使用它们。
** 引用
  引用(quote)是一种特殊表达式，它返回它的参数且不对其进行求值。它提供了一种在程序里包含标识符常
  量和列表却不需要对其求值的使用方式。
  #+BEGIN_SRC emacs-lisp
  (quote object)
  #+END_SRC
  它返回object，但不对object进行求值操作。它提供了一种简写方式，即“'”， *'object* 。
** 反引号
  反引号(backquote `)可用于列表，它与引用唯一的区别的，它允许对列表中部分元素进行求值。采用逗
  号(,)来标识那些元素需要进行求值，下面是一些例子：
  #+BEGIN_SRC emacs-lisp
  `(a list of ,(+ 2 3) elements)  ;; ⇒ (a list of 5 elements)
  `(1 2 (3 ,(+ 4 5)))             ;; ⇒ (1 2 (3 9))
  #+END_SRC
* 控制结构
** 控制结构
  Lisp程序由一系列表达式结成，Lisp解释器解释并执行这些表达式。在执行这些表达式过程中用到了控制
  结构，Lisp里的控制结构都是特殊表达式（Special Forms）。最简单的控制结构是顺序执行，也是符合
  人的书写和线性习惯。其他控制结构有：条件语句、迭代。
** 顺序结构
  顺序结构是最简单的控件结构，如果想自己定义顺序结构，可以采用 *progn* 这个特殊表达式:
  #+BEGIN_SRC emacs-lisp
  (progn a b c ...)
  #+END_SRC
  它的执行结构是最后一句的结果。与之类似有另一个特殊表达式 *(prog1 form1 forms...)* 它也
  是顺序执行，不过它的返回值是form1的返回值。同时还有一个特殊表达式 *(prog2 form1 form2 forms...)*
  它效果也是一样，不过它返回的是form2的值。
** 条件语句
  ELisp提供四种条件语句：if、when、unless和cond
*** if
   if语句跟其他语言的if语言类似，它的结构如下：
   #+BEGIN_SRC emacs-lisp
   (if condition then-form else-forms...)
   #+END_SRC
   这里有一点要引起注意的是当condition为nil,并且没有给定else-forms时，if返回的是nil。
*** when
   when是if的变体，是当没有else-forms的特殊情况：
   #+BEGIN_SRC emacs-lisp
   (when condition then-forms. . .)
   #+END_SRC
*** unless
   unless也是if的一个变体，是当没有then-form的特殊情况：
   #+BEGIN_SRC emacs-lisp
   (unless condition forms...)
   #+END_SRC
*** cond
   cond是一种选择条件语句，每一个条件语句必须是一个列表，其中列表的头(car clause)是条件，列表
   的其他部分是执行语句。cond的执行过程是按顺序执行，对每个条件语句clause，先对条件部分进行求值，
   如果条件的执行结果不是nil，说明条件满足，则接下来执行条件语句的主体部分，最后返回主体部分的执
   行结果作为cond的结果，其他部分的条件语句则被忽略。
   #+BEGIN_SRC emacs-lisp
   (cond ((numberp x) x)
         ((stringp x) x)
         ((bufferp x)
          (setq temporary-hack x) ; multiple body-forms
          (buffer-name x))        ; in one clause
         ((symbolp x) (symbol-value x)))
   #+END_SRC
   有时候当前面所有的条件语句都没有“命中”时，可以采用t进行默认处理，下面是一个例子：
   #+BEGIN_SRC emacs-lisp
   (setq a 5)
   (cond ((eq a 'hack) 'foo)
         (t "default"))           ;; ⇒ "default"
   #+END_SRC
** 迭代语句
  迭代在程序语言里表示重复执行某段代码，举例来说，如果你想对list的每个元素重复执行相同的计算，这
  就是一个迭代过程。
*** while
   while的定义如下：
   #+BEGIN_SRC emacs-lisp
   (while condition forms...)
   #+END_SRC
   while首先对condition进行求值操作，如果结果不是nil，则执行forms里语句；接下来再次对condition
   进行求值，如果不是nil，则执行forms里的语句；这个过程不断重复直到condition的求值为nil。
   #+BEGIN_SRC emacs-lisp
   (setq num 0) ;; ⇒0
   (while (< num 4)
     (princ (format "Iteration %d." num))
     (setq num (1+ num)))
   #+END_SRC
*** dolist
   dolist的定义如下:
   #+BEGIN_SRC emacs-lisp
   dolist (var list [result]) body...
   #+END_SRC
   dolist对list里的每个元素执行body里的语操作，这里绑定list里的每个元素到var作为局部变量。
   最后返回result，当result省略时，返回nil。下面是一个例子：
   #+BEGIN_SRC emacs-lisp
   (defun reverse (list)
      (let (value)
       (dolist (elt list value)
         (setq value (cons elt value)))))
   #+END_SRC
*** dotimes
   dotimes的定义如下：
   #+BEGIN_SRC emacs-lisp
   dotimes (var count [result]) body...
   #+END_SRC
   它的作用与dolist很类似，它从0(包含)到count(不包含)执行body语句，将当前的值绑定到var，返回
   result作为结果。下面是一个例子：
   #+BEGIN_SRC emacs-lisp
   (dotimes (i 100)
            (insert "I will not obey absurd orders\n"))
   #+END_SRC
* 变量
** 变量
  变量在程序中是一种标识符，其指向某个值，这是一个很通用的编辑概念，不需要做过多解析。在Lisp中，
  每个变量都通过符号类型来表达。变量名就是对应的符号类型名，变量值是保存在符号类型的值单元(value cell)里。
  注意在前一章节里，我们介绍到符号类型既可用于变量名也可用于函数名，它们是相互独立不冲突的。
** 全局变量
  全局变量在任意时刻都只有一个值，并且这个变量可使用于整个lisp运行环境。我们经常用 *setq* 这个
  特殊表达式将一个值绑定到具体某个符号变量中，如下：
  #+BEGIN_SRC emacs-lisp
  (setq x '(a b))
  #+END_SRC
  这里setq是一个特殊表达式，所以它不会对第一个参数x进行求值，它会对第二个参数进行求值，然后将求
  得的值绑定到第一个参数对应的变量中。
*** 不变量
   在Emacs Lisp中，某些符号类型的求值是其本身。最常见的如nil、t，以及以:开头的符号类型（这些
   符号类型称之为关键字keywords）。这些特殊的变量不能再进行绑定，同时其值也无法进行修改。
   #+BEGIN_SRC emacs-lisp
   (keywordp object)
   #+END_SRC
   用来判断一个对象是否为关键字类型(keywords)，即以:开头的符号类型。
*** 定义全局变量
   变量的定义主要有三个目的: 首先，它 提示阅读代码人的，该符号变量用于一种特殊用途（这里用于变量）;
   其次，它提供给Lisp系统，有时候还会赋于初始值和文档；最后，它为编程工具提供信息，如etags，提
   示它去哪里找到变量定义。定义全局变量采用
   *defvar* 关键字，它定义一个符号类型为变量。
   #+BEGIN_SRC emacs-lisp
     defvar symbol [value [doc-string]]
   #+END_SRC
   还有一种方式，采用 *defconst* 关键字
   #+BEGIN_SRC emacs-lisp
     defconst symbol value [doc-string]
   #+END_SRC
** 变量是无效的
  当一个符号类型对应的值单元没有被赋值(unassigned)时，称对应的变量为无效的(void)。对于个无效
  变量进行求值，会抛出 *void-variable error* 。 注意变量为无效的(void)与变量值为nil本质上
  是不一样的，nil为一种对象，它可以赋值给变量。
  #+BEGIN_SRC emacs-lisp
  (makunbound symbol)
  #+END_SRC
  makunbound清空符号类型里值单元，使得一个变量成为无效的(void)。它返回符号类型。
  #+BEGIN_SRC emacs-lisp
  (boundp variable)
  #+END_SRC
  boundp 当variable不是无效的(nil)时返回t，否则返回nil。
** 局部变量
  局部变量一般只用于一段程序，最常用的声明方式是采用 *let* 关键字。它的定义格式如下：
  #+BEGIN_SRC emacs-lisp
  let (bindings. . . ) forms. . .
  #+END_SRC
  这里的let是一个特殊表达式(Special Forms)，它按顺序绑定局部变量。下面是一个例子:
  #+BEGIN_SRC emacs-lisp
  (let ((y 1)
        (z y))
     (list y z))  ;; ⇒ (1 2)
  #+END_SRC
  还有一种局部变量，即函数的调用参数，因为这些参数只用于函数调用阶段。
** Buffer本地变量(Buffer-Local Variables)
  Buffer本地变量，从字面意思可以看出，这种类型的变量只应用于Buffer中。这种机制可以满足对于同一
  个变量在不同的Buffer中的值不一样。
** 文件本地变量(File-Local Variables)
* 函数
** 什么是函数？
  函数是有传入参数的可计算的单元。每个函数的计算结果为函数返回值。大部分计算机语言里，每个函数有
  其自己函数名。从严格意义来说，lisp函数是没有名字的。lisp函数其本质是一个对象，该对象可关联到
  一个标识符（本书把Symbol翻译成标识符）,这个标识符就是函数名。
** 定义函数
  定义一个函数的语法如下：
  #+BEGIN_SRC emacs-lisp
  defun name args [doc] [declare] [interactive] body. . .
  #+END_SRC
*** 检查一个函数是否定义
   检查一个变量是否绑定到函数， *fboundp symbol* , 还有一个函数 *(functionp OBJECT)*
   #+BEGIN_SRC emacs-lisp
   (fboundp 'info)                         ; t
   (fboundp 'setq)                         ; t
   (fboundp 'xyz)                          ; nil
   (functionp (lambda () (message "Anonymous Functions")))   ; t
   (fboundp (lambda () (message "Anonymous Functions")))     ; *** Eval error ***
   #+END_SRC
*** 函数参数
   有些参数是可选的，当用户没有传时，设置一个默认值，下面是一个例子：
   #+BEGIN_SRC emacs-lisp
   (defun cookbook/fun-option-parameter (a &optional b &rest e)
     (when (null b)
       (message "paramete b is not provided")
       (setq b "ddd"))    ;; set to default value
     (message "a=%s, b=%s" a b))
   #+END_SRC
   函数cookbook/fun-option-parameter中，a为必传参数，b为可选择参数，e为其余参数，当实际传
   入的参数大于2时，其他参数将组成一个list绑定到e上。
** 函数调用
  最通用的函数的调用方式是对list进行求值，如对list *(concat "a" "b")* 进行求值，相当于用参
  数"a"和"b"调用函数concat。这种方式用在你清楚程序上下文中调用哪个函数、传递哪个参数。但有时候
  你需要在程序运行时才决定调用哪个函数。针对这种情况，Emacs Lisp提供了另外两种方式 *funcall*
  和 *apply* 。其中apply一般用在运行时行决定传递多少个参数的情况。
*** funcall
   funcall它的语法如下：
   #+BEGIN_SRC emacs-lisp
   funcall function &rest arguments
   #+END_SRC
   这里funcall本身是一个函数，因此funcall在调用前，它的所有参数都将事先做求值运算，对funcall
   来说它不知道具体的求值过程。同时请注意第一个参数 *function* 必须为一个Lisp函数或者原生函数，
   不能为特殊表达式(Special Forms)和宏，但可以为匿名函数（lambda表达式）。
   下面为一个例子：
   #+BEGIN_SRC emacs-lisp
   (setq f 'list)        ;; ⇒ list
   (funcall f 'x 'y 'z)  ;; ⇒ (x y z)
   #+END_SRC
*** apply
   apply的定义如下：
   #+BEGIN_SRC emacs-lisp
   apply function &rest arguments
   #+END_SRC
   apply与funcall作用一样，唯独有一点不一样：它的arguments是一个对象列表，每个对象作为单独的
   参数传入，如下例子:
   #+BEGIN_SRC emacs-lisp
   (setq f 'list)         ;; ⇒ list
   (apply f 'x 'y 'z)     ;; Wrong type argument: listp, z
   (apply '+ 1 2 '(3 4))  ;; ⇒ 10
   #+END_SRC
*** 映射函数(Mapping Functions)
   映射函数操作是指对一个列表或者集合逐个执行指定函数，这节介绍几个常的映射函数：mapcar,
   mapc, 和 mapconcat。
   #+BEGIN_SRC emacs-lisp
   mapcar function sequence
   #+END_SRC
   这个函数功能有与javascript里的array.map操作类型，对 *sequence* 里的每个元素执行function
   操作，返回操作结果列表。这个函数应用非常广泛，以下几个应用举例：
   #+BEGIN_SRC emacs-lisp
   (mapcar 'car '((a b) (c d) (e f)))   ;; ⇒ (a c e)
   (mapcar '1+ [1 2 3])                 ;; ⇒ (2 3 4)
   (mapcar 'string "abc")               ;; ⇒ ("a" "b" "c")
   #+END_SRC
   *mapc* 与 *mapcar* 调用方式一样，唯一不同的点是它始终返回的是 *sequence* 。
   #+BEGIN_SRC emacs-lisp
   mapconcat function sequence separator
   #+END_SRC
   *mapconcat* 对 *sequence* 里的每个元素调用 *function* 最后将结果拼接成一个字符串作为返
   回值，采用separator作为拼接符。
** 匿名函数
  在elisp里有三种方式可以定义匿名函数： *lambda* 宏、 *function* 特殊表达式、 *#'* 可读语
  法。
*** lambda宏
   它的定义如下：
   #+BEGIN_SRC emacs-lisp
   lambda args [doc] [interactive] body. . .
   #+END_SRC
   这个宏返回一个匿名函数，实际上这个宏是自引用(self-quoting)。
   #+BEGIN_SRC emacs-lisp
   (lambda (x) (* x x))  ;; ⇒ (lambda (x) (* x x))
   #+END_SRC
   下面是另一个例子：
   #+BEGIN_SRC emacs-lisp
   (lambda (x)
       "Return the hyperbolic cosine of X."
       (* 0.5 (+ (exp x) (exp (- x)))))
   #+END_SRC
   上面的表达式被计算成一个函数对象。
*** function特殊表达式
   定义如下：
   #+BEGIN_SRC emacs-lisp
   function function-object
   #+END_SRC
   这是一个特殊表达式(Special Forms)，表示对 *function-object* 不作求值操作。其实在实际使
   用中我们往往采用它的简写 *#'* ，因此下面三个是等价的：
   #+BEGIN_SRC emacs-lisp
   (lambda (x) (* x x))
   (function (lambda (x) (* x x)))
   #'(lambda (x) (* x x))
   #+END_SRC
** 获取函数单元内容
  当我们把一个标识符(Symbol)定义为函数，其本质是将函数对象存储在标签符号对应的函数单元（标识符
  还有一个变量单元用于存储变量）,下面是介绍函数单元处理方法:
*** symbol-function
   定义如下：
   #+BEGIN_SRC emacs-lisp
   symbol-function symbol
   #+END_SRC
   这个函数返回标识符symbol对应的函数对象，它不校验返回的函数是否为合法的函数。如果symbol的函数
   单元为空，返回nil。
*** fboundp
   用于判断symbol对应的函数单元是否为nil
   #+BEGIN_SRC emacs-lisp
   fboundp symbol
   #+END_SRC
   当symbol在函数单元有一个对象时返回t，否则返回nil。
** 特殊表达式(Special Forms)和宏
  有些与函数看起来很像的类型，它们也接受参数，同时计算出结果。但在Elisp里，他们不被当成函数，下
  面给出简单介绍：
*** 内建函数(primitive)
   是用C语言写的，可被调用的函数；
*** special form
   一种类型的内建函数，如if, and 和while
* 文件
** 文件及访问
  文件是操作系统永久保存数据的单元，为了编辑文件，我们必要告诉Emacs去读取一个文件，并将文件的内
  容保存在一个Buffer里，这样Buffer与文件就关联在一起。下面介绍与文件访问相关的函数，由于历史原
  因这些函数的命令都是以 *find-* 开头的，不是以 *visit-* 开头。
*** 打开文件
   如果想在buffer里打开一个文件，其命令是 *find-file* (C-x C-f)。当文件已经在buffer中存在时，
   这个命令返回文件对应的buffer。如果当前没有buffer对应文件，则，创建一个buffer，并将其文件
   内容读到buffer中，并返回这个buffer。字义如下:
   #+BEGIN_SRC emacs-lisp
   (find-file filename &optional wildcards)
   #+END_SRC
   这个函数有一个对应的hook变量，叫 *find-file-hook* 它的值是一个函数列表。这些函数在文件被
   打开后依次执行。
*** 文件保存
   文件被载入到buffer后，我们可以对其进行修改；修改完了后，将内容保存回文件，其对应的函数为：
   #+BEGIN_SRC emacs-lisp
   (save-buffer &optional backup-option)
   #+END_SRC
   文件保存对应有两个hook变量，为： *before-save-hook* 和 *after-save-hook* 分别表示保
   存前的hook函数列表和保存后的hook函数列表。与之类似的还有一个函数 *write-file*
   #+BEGIN_SRC emacs-lisp
   (write-file  filename &optional confirm)
   #+END_SRC
   这个函数的功能是将当前buffer的内容写入到filename对应的文件中，并将当前buffer与这个文件进
   行关联
*** 读取文件内容(Reading from Files)
   将文件内容复制到buffer，可以使用 *insert-file-contents* 函数，注意在Lisp代码里不要使用
   *insert-file* 命令，因为它会设置mark标识。
   #+BEGIN_SRC emacs-lisp
   (insert-file-contents filename &optional visit beg end replace)
   #+END_SRC
   这个函数在当前buffer的位置插入文件 *filename* 的内容，它返回一个它包含一个文件名和数据长度
   信息的列表。如果文件不存在(或不可读)，则会抛出错误异常!当这个函数执行后会调用 *after-insert-file-functions*
   列表里的函数。一般情况下，在这个列表里的函数其中有一个是用来检测文件内容的编码。与这个函数类似
   的一个函数为(insert-file-contents-literally filename &optional visit beg end [Function] replace)
   ，它们唯一的区别的后者不内容进行格式化、不对字符做转换。
   如果参数visit不是nil时，执行这个函数后会将当前buffer设置为未修改（unmodified）状态。
*** 往文件里写内容(Writing to Files)
   将buffer里的内容（或者部分内容）直接写入到一个文件，可以采用 *append-to-file* 和 *write-region*
   函数。注意这里不要写入正在访问的文件，否则会出现异常情况：
   #+BEGIN_SRC emacs-lisp
   (append-to-file start end filename)
   #+END_SRC
   这个函数的作用是将当前buffer里的部分内容（从start到end部分内容）追加到文件 *filename* 的
   后面。如果是在lisp中使用，这个函数完全等价于 (write-region start end filename t)。
   #+BEGIN_SRC emacs-lisp
   (write-region start end filename &optional append visit lockname mustbenew)
   #+END_SRC
   这个函数的作用与append-to-file类似，不过其参数更多。
   1. 当start为nil时，这个函数写入的是当前buffer所有内容，这时end参数没有用;
   2. 当start为string时，这个函数写入的内容是string的内容，这时end参数失效;
   3. 当append不是nil时，表示往现有文件里进行追加，当append是一个数字时，表示从当前文件开始到append的位置开始写入。
   4. 当mustbenew不为nil时，当覆盖已有文件时，会询问用户，并获得用户确定后再操作。
   #+BEGIN_SRC emacs-lisp
   (with-temp-file file body)
   #+END_SRC
   *with-temp-file* 是一个宏操作，它将创建一个临时buffer作为当前buffer，在这个buffer里对
   body进行求值，最后将这个buffer的内容写入到文件 *file* 里。当整个body执行完成后，Emacs将
   会把这个临时buffer关闭，恢复到执行with-temp-file之前的当前buffer。它将body的最后执行结
   果作为with-temp-file的返回结果。
** 文件锁
  当多个用户同时修改一个文件里，这时候需要文件锁。Emacs里的文件锁是保存在同一目录下的一个文件，
  它有一个特殊的名字.
  #+BEGIN_SRC emacs-lisp
  (file-locked-p filename)
  #+END_SRC
  *file-locked-p* 这个函数用来检查文件是否被锁。当文件没有被锁，则返回nil；如果被Emacs进程
  锁了，则返回t，当被其他job锁了，则返回使用都信息。
  #+BEGIN_SRC emacs-lisp
  (lock-buffer &optional filename)
  #+END_SRC
  如果当前buffer被修改过，这个函数锁定当前buffer所关联的文件。与之相对应的操作有解锁，可以使用
  (unlock-buffer) 这个函数。
  #+BEGIN_SRC emacs-lisp
  (ask-user-about-lock file other-user)
  #+END_SRC
  当一个用户修改正在被另一个用户锁定的文件时，询问用户。该函数的返回值（即用户的选择），决定Emacs
  接下来该如何执行。
** 文件基本信息函数
  下面介绍一些与文件基本信息相关的函数
*** 文件是否存在
   判断一个文件是否存在采用 *file-exists-p* 这个函数:
   #+BEGIN_SRC emacs-lisp
  (file-exists-p filename)
   #+END_SRC
   与之类似的有: *file-readable-p* 、 *file-executable-p* 、 *file-writable-p* 、
   *file-directory-p* *file-symlink-p* 这几个函数。
*** 文件新旧比较
   #+BEGIN_SRC emacs-lisp
   (file-newer-than-file-p filename1 filename2)
   #+END_SRC
   当filename1比filename2新时，该函数返回t。如果filename1不存在，则返回nil。如果filename1
   存在，但filename2不存在，则返回t。
*** 文件模式
   #+BEGIN_SRC emacs-lisp
   (file-modes filename)
   #+END_SRC
   这个函数返回文件的属性，跟linux里的chmod命令相对应，它返回的是一个整数：它包含了文件的读、
   写和可执行权限。
   #+BEGIN_SRC emacs-lisp
   (file-modes "~/junk/diffs")   ;; ⇒ 492 ; Decimal integer.
   #+END_SRC
*** 文件属性
   这小节介绍与文件属性有关的一些函数，如文件的所属人、所属组、文件大小、文件的最新读取和修改时
   间等。
   #+BEGIN_SRC emacs-lisp
   (file-attributes filename &optional id-format)
   #+END_SRC
   这个函数返回文件对应的属性列表，下面是一个调用示例：
   #+BEGIN_SRC emacs-lisp
   (file-attributes "~/tree.txt")
   ;; 返回如下
   (nil 1 501 20
        (23331 5030 438781 943000)
        (23331 4821 822935 764000)
        (23331 4821 822935 764000)
        10496 "-rw-r--r--" t 8602715307 16777220)
   #+END_SRC
   属性列表按顺序说明如下：
   0. t 表示目录，字符串表示符号链接，nil 为文本文件；
   1. 这个文件有多少名字与之关联，一般为1，当有符号链接时不一样；
   2. 文件的UID;
   3. 文件的GID;
   4. 文件最近accessTime，有4个元素的列表(sec-high sec-low microsec picosec);
   5. 文件最后修改时间；
   6. 文件状态最后被修改时间；主要是用chmod来改变文件模式;
   7. 文件大小，单位byte;
   8. 文件模式；
   9. 未使用值，主要用来做向下兼容；
   10. 文件的inode编码；
   11. 设备的文件系统码；
** 文件查找
*** locate-file
   #+BEGIN_SRC emacs-lisp
   (locate-file filename path &optional suffixes predicate)
   #+END_SRC
   *locate-file* 这个函数用来查找在path目录下文件名为filename的文件，如果找到则返回绝对文件
   名。注意第二个参数path必需为目录列表，像 *exec-path* 对应的列表一平。下面是一个例子：
   #+BEGIN_SRC emacs-lisp
   (locate-file "03_file.org" '("/Users/aborn/github/emacs-cookbook/chapters/"))
   ;; "/Users/aborn/github/emacs-cookbook/chapters/03_file.org"
   (locate-file "03_file" '("/Users/aborn/github/emacs-cookbook/chapters/") '(".tex" ".org"))
   ;; "/Users/aborn/github/emacs-cookbook/chapters/03_file.tex"
   #+END_SRC
   可选参数 suffixes 为后缀列表，查找所有后缀，以第一个查到为准。
*** executable-find
   #+BEGIN_SRC emacs-lisp
   (executable-find program)
   #+END_SRC
   executable-find用于查找可执行文件，查找所有 *exec-path* 目录下的可执行文件（以及查找所
   有后缀为exec-suffixes列表里的可执行文件），下面是一个例子:
   #+BEGIN_SRC emacs-lisp
   (executable-find "emacs")
   ;; "/usr/local/bin/emacs"
   #+END_SRC
** 文件与目录
  判断文件是否在一个目录下，怎么做?
  #+BEGIN_SRC emacs-lisp
  (file-in-directory-p  file dir)
  #+END_SRC
  如果file是一个在目录dir或者dir子目录下的文件，则返回t。如果file与dir处于同一目录，也返回t。
  如果想列出一个目录下的所有文件，那就要用到 *directory-files* 这个函数，其定义如下：
  #+BEGIN_SRC emacs-lisp
  (directory-files directory &optional full-name match-regexp nosort)
  #+END_SRC
  这个函数按字母顺序返回目录 directory 下的所有文件。参数 full-name 不为nil时，则返回每个文
  件的绝对路径，否则返回相对路径。match-regexp 如果不是nil，该函数返回只与match-regexp相匹
  配的文件列表。nosort如果不为nil，则不按字母排序。
*** 创建、复制和删除目录
   对目录的创建、复制和删除都有相关的处理函数，下面一一介绍：
   #+BEGIN_SRC emacs-lisp
   (make-directory dirname &optional parents)
   #+END_SRC
   *make-directory* 创建一个目录名为dirname的目录
** 文件名
  下面介绍一些与文件名操作有关的函数
  #+BEGIN_SRC emacs-lisp
  (file-name-directory filename)
  #+END_SRC
  *file-name-directory* 返回的文件名里的目录部分，如果文件名里没有包含目录部分，则返回nil。
  与这个函数对应的一个函数为 *file-name-nondirectory* ，它返回非目录部分。
*** 文件路径
   *expand-file-name* 这个函数将文件名转成绝对文件名：
   #+BEGIN_SRC emacs-lisp
   (expand-file-name filename &optional directory)
   #+END_SRC
   如果directory参数存在，将filename作为其相对路径，否则使用 *default-directory* 变量。
   这个函数在写elisp代码时经常用到，下面是一些例子:
   #+BEGIN_SRC emacs-lisp
   (expand-file-name "foo")
   ;; ⇒ "/xcssun/users/rms/lewis/foo"
   (expand-file-name "../foo")
   ;; ⇒ "/xcssun/users/rms/foo"
   (expand-file-name "foo" "/usr/spool/") ⇒ "/usr/spool/foo"
   #+END_SRC
   与expand-file-name相似的函数还有 *file-truename* 这个函数
   #+BEGIN_SRC emacs-lisp
   (file-truename filename)
   #+END_SRC
   下面是一些例子
   #+BEGIN_SRC emacs-lisp
   (file-truename "~/tree.txt")       ;;  "/Users/aborn/tree.txt"
   (file-truename "../tree.txt")      ;; "/Users/tree.txt"
   (file-truename "../../tree.txt")   ;; "/tree.txt"
   #+END_SRC
* 多线程
** 多线程
  Emacs从26.1版本开始引入了[[https://www.gnu.org/software/emacs/draft/manual/html_node/elisp/Threads.html][多线程]] 。它提供了一种简单（但功能有限）多线程操作。跟其他编程语言一
  样，在同一个Emacs实例里所有的线程的内存是共享的。每个线程有其自己运行Buffer(Current Buffer)
  和对应的数据(Match Data)。注意：下面的文档都是参考Emacs的草案手册。
** 基本的线程相关函数
  下面介绍线程操作相关的[[https://www.gnu.org/software/emacs/draft/manual/html_node/elisp/Basic-Thread-Functions.html#Basic-Thread-Functions][基本函数]]。
*** 创建线程
   我们可以通过 *make-thread* 函数来创建线程并执行对应的task。它的语法如下:
   #+BEGIN_SRC emacs-lisp
  (make-thread function &optional name)
   #+END_SRC
   创建一个名为name的线程，该线程执行function函数，当函数执行结束后，退出该线程。新线程的Current
   Buffer继承当前Buffer，这个函数返回一个线程对象。可以通过 *(threadp object)* 来判断一个对
   象是否为线程对象。
*** thread-join
   thread-join，它阻塞当前执行直到线程执行完成，如果线程已经退出，它立刻返回。
   #+BEGIN_SRC emacs-lisp
   (thread-join thread)
   #+END_SRC
*** thread-yield
   执行下一个可执行的线程。
*** 获取线程名
   可以通过(thread-name thread)函数来获取线程名。
*** 线程状态
   判断一个线程是否还在执行(alive)，可以用(thread-alive-p thread)。
*** 当前线程
   (current-thread)返回当前线程。
*** 所有线程列表
   获取当前所有正在运行中的线程(all-threads)。
** 互斥锁(Mutexes)
  [[https://www.gnu.org/software/emacs/draft/manual/html_node/elisp/Mutexes.html][互斥]] 是一种排它锁(exclusive lock)，在任何时刻，最多只允许一个线程持有互斥锁。也就是说，当一个线
  程试图获取一个已经被其他线程持有的互斥锁时，它会引发阻塞，直到该互斥锁被释放为止。
*** 创建一个互斥锁
   创建一个互斥锁对象，采用 *make-mutes* 函数，该函数返回一个互斥锁对象，其名字为name。
   #+BEGIN_SRC emacs-lisp
   (make-mutex &optional name)
   #+END_SRC
   判断一个对象是否为互斥锁使用(mutexp object)。
*** 获取/释放互斥锁
   #+BEGIN_SRC emacs-lisp
  （mutex-unlock mutex）
   #+END_SRC
   这个操作会引发阻塞，直到当前线程获取互斥锁为止。与之相对的有(mutex-unlock mutex)释放互斥
   锁操作。
*** with-mutex
   #+BEGIN_SRC emacs-lisp
   (with-mutex mutex body)
   #+END_SRC
   这是一个宏操作，它首先获取一个互斥锁，然后执行body里的行为，最后释放互斥锁。
** 条件变量(Condition Variables)
  [[https://www.gnu.org/software/emacs/draft/manual/html_node/elisp/Condition-Variables.html][条件变量]] 提供线程阻塞直到某个事件发生的机制。线程可以等待一个条件变量，直到别的线程触发这个条件
  才唤醒。条件变量在某些情况下往往与互斥机制相关联。下面是一个例子：
  #+BEGIN_SRC emacs-lisp
  (with-mutex mutex
    (while (not global-variable)
      (condition-wait cond-var)))
  #+END_SRC
  这里互斥锁保证了原子性。
  #+BEGIN_SRC emacs-lisp
  (with-mutex mutex
    (setq global-variable (some-computation))
    (condition-notify cond-var))
  #+END_SRC
*** 创建条件变量
   创建条件变量的函数如下：
   #+BEGIN_SRC emacs-lisp
   (make-condition-variable mutex &optional name)
   #+END_SRC
   创建一个与互斥锁mutex的条件变量，其名字为name。判断一个对象是否为条件变量使用
   (condition-variable-p object)
*** 条件等待
   #+BEGIN_SRC emacs-lisp
   (condition-wait cond)
   #+END_SRC
   等待另一个线程去触发条件 *cond* （它是一个条件变量）。这个函数也会阻塞主流程直到条件被触发
   为止。condition-wait 在等待时会释放与之关联的互斥锁，允许其他线程去获取这个互斥锁从而触发
   条件变量。
*** 条件通知
   #+BEGIN_SRC emacs-lisp
   (condition-notify cond &optional all)
   #+END_SRC
   通知 *cond* 条件变量。一般情况下，一个等待线程被condition-notify被唤醒，当all不是nil时，
   所有等待cond的线程都将收到唤醒通知。
*** 其他函数
   1. (condition-name cond) 返回条件变量名
   2. (condition-mutex cond) 返回与条件变量相关联的互斥锁
* org 实践
** org模式简介
  Emacs的org-mode可用于记笔记、管理自己的待办事项(TODO lists)，同时，也可用于管理项目。它是一个高效的纯文本编辑系统。
** 文档结构
  Org是基于Outline-mode，并提供灵活的命令编辑结构化的文档。其文档结构语法跟markdown很类似。
*** 目录结构
   Org的目录结构在每行最左边以星号标记，星号越多，标题层级越深。下面是一些例子：
   #+BEGIN_EXAMPLE
   \* 一级目录
   \** 二级目录
   \*** 三级目录
   \* 另一个一级目录
   #+END_EXAMPLE
*** 显示与隐藏
   目录结构下的内容可以隐藏起来，通常用采用 *TAB* 和 /S-TAB/ 这两个命令来切换。
*** 列表
   Org提供三种类型的列表：有序列表、无序列表和描述列表
   1. 有序列表以'1.' 或者 '1)'
   2. 无序列表以'-', '+' 或者 '*'
   3. 描述列表
*** 块结构
   在Org文档中，加入代码块这种类型的块结构，都是采用begin...end这种模式，下面是一个例子：
   #+BEGIN_EXAMPLE
\#+BEGIN_EXAMPLE
\#+END_EXAMPLE
   #+END_EXAMPLE
** 表格
** 超链接
  Org模式提供了比较好用的超链接方式，可以链接到普通网页、文件、email等。
*** 链接格式
   Org模式支持两种链接，即，内部链接和外部链接。它们有相同的格式：
   #+BEGIN_EXAMPLE
[[链接][描述]]  或 当只有链接没有描述  [[链接]]
   #+END_EXAMPLE
   一旦链接编辑完成，在org模式下，只显示 *描述* 部分，而不会显示整体（后一种是只显示链接）。
   为了编辑链接和描述，需要通过快捷键 *C-c C-l* 来完成(注意：编辑结束后按Enter完成修改操作)。
**** 内部链接
    内部链接是指向当前文件的链接,它的链接格式:
    #+BEGIN_EXAMPLE
[[#链接ID]]
    #+END_EXAMPLE
    其中 *链接ID* 是文档中唯一的标识ID
**** 外部链接
    Org支持的外部链接有很多中形式，如文件、网页、新闻组、电子邮件信息、BBDB数据条目等。
    它们以一个短的标识字符串打头，紧接着是一个冒号，冒号后面没有空格字符。
*** 链接处理相关命令
   Emacs org提供了很多链接处理相关的函数
   + org-store-link 保存的一个链接到当前位置，以备后面插入使用，原始绑定的快捷键为 *C-c l*
   + org-insert-link 插入链接，绑定的快捷键为C-c C-l，如果光标正在一个链接上，那么这个命令
   的行为是编辑这个链接及其描述。
   + org-open-at-point 打开当前位置的链接。它将在浏览器中打开这个链接，快捷键为 *C-c C-o*
   其实使用是的 *browse-url-at-point*
** 待办事项
  Org模式用来管理自己的TODO list非常方便
** 日程表(Agenda View)
  我们可以用Org来按排自己的行程
*** 日程文件(Agenda files)
   变量org-agenda-files保存了一个文件列表,这些文件用来记录日程，下面是一些操作函数:
   C-c [ 将当前文件加入到agenda文件列表最前页面 org-agenda-file-to-front
   C-c ] 将当前文件从agenda文件列表中删除 org-remove-file
*** 分发按键
   默认采用 *C-c a* ,接下的默认的命令有：
   + a   创建一个日程
   + t/T 创建一个TODO items
   + L   对当前文件生成timeline
*** 内建Agenda视图
*** 计划Schedule
   用org来安排日程
   + org-schedule 将当前TODO添加计划时间
** Org快速记录
  有时候，突然想到一些待办事项，或者一些突发的灵感。这时，我们想用emacs快速记录它，[[http://orgmode.org/manual/Capture.html#Capture][Org-Capture]] 提供
  这个好用的功能。它的前身是org-remember.el（注：从org 8.0开始，org-remember被org-capture）
  替代。
*** 如何使用org-capture?
   快速记录的命令为 *M-x org-capture* ，默认绑定的快捷键为 C-c c 。当这个命令被调用后，你可以使用
   自己定义好的 [[http://orgmode.org/manual/Capture-templates.html#Capture-templates][模板]] 快速创建记录。一旦完成内容的输入，按下C-c C-c (org-capture-finalize)，来完成。
   然后，你就能继续做你当下的事。如果想跳转到刚刚创建的记录的buffer, 用C-u C-c C-c来完成。如果想
   中途中止输入，只要按下 C-c C-k (org-capture-kill)。
*** org条目复制与移动
   有时候，我们想将当前的某条目转移到其他文件或者其他项目里。这时，我们会用到 org-copy 和 org-refile
   这两个命令。它们对应的快捷键分别是 C-c M-w 及 C-c C-w 。这里有一个问题是，目标文件如何配置？
   目录文件的配置由一个变量决定， *org-refile-targets* ，我自己的配置如下：
   #+BEGIN_SRC emacs-lisp
(setq org-refile-targets
      '((nil :maxlevel . 3)       ;; 当前文件的最大层级
        (aborn-gtd-files :maxlevel . 3)))
   #+END_SRC
   注意：我这时将文件放在 aborn-gtd-files 文件列表里。
*** 记录模板
   记录的模板为一个列表变量，org-capture-templates，列表的每条记录由如下几段组成：
   #+BEGIN_EXAMPLE
("t" "Todo" entry (file+headline (expand-file-name org-default-notes-file org-directory) "Tasks")
         "* TODO %?\n  创建于:%T  %i\n")
   #+END_EXAMPLE
**** 快捷键
    如例子中的那样，"t"表示对应按键t这个快捷键。它能帮助我们快速地选中哪条模板进行快速记录。
**** 描述
    接下来是一段简单的描述
**** 类型
    第三段表示类型，有五种类型：entry item checkitem table-line plain
    + entry 普通的Org结点，保证目标文件为org-mode文件，插入的时候将作为目录结点的子结点
    （如果没有，将做为顶级结点）；
    + item 与entry类似，不同点在于它的目标文件可以为简单的纯文本文件；
    + checkitem 复选条目；
    + table-line 在目标文件中的第一个table中插入新行；
    + plain 纯文本记录
**** 目标文件
    第四个字段配置目标文件
**** 模板
    第五个字段表示模板，[[http://orgmode.org/manual/Template-expansion.html#Template-expansion][模板参数]] 含义如下：
    + %t 只有日期的时间戳
    + %T 日期+时间的时间戳
    + %u,%U 如上，只不过它们是inactive的
    + %i 初始化文本，当前上下文将作为初始化文本
**** 属性properties
    最后一个字段表示属性列表，支持以下属性配置：
    + :prepend 一般一个记录条目插入在目标文件的最后，这个属性可以将条目插入在最前
    + :immediate-finish 立刻完成，没有交互
    + :clock-in 对这个条目设置闹钟
    + :kill-buffer 如果目标文件没有相应的访问buffer,插入后，自动关闭buffer
** Org的导出功能
  Org文件支持导出多种格式的目标文件，如ASCII文件、HTML文件(用于发布为Web)、PDF文档等。
*** 导出的Dispatcher
   任何导出命令都有一个前缀按键，我们称之为Dispatcher，为 *C-c C-e*
** org-capture.el
  Org 8.0 以后版本采用org-capture.el取代原有的org-remember.el
* 书签
** emacs的书签功能
  emacs的书签用于记录你在文件中的阅读位置。它有点类似寄存器，跟寄存器一样，因为它也能记录位置位置。
  但同寄存器有两点不一样：1. 它有比较长的名字; 2. 当emacs关闭的时候，它会自动持久化到
  磁盘。
*** 设置一个书签
   当我们阅读一个很长的文档，没能一口气读完时。我们希望记住当前文档的最后阅读的位置，以便下次再用emacs
   阅读的时候能快速地定位到。那么，我们设置一个书签，通过
   *bookmark-set* 对应快捷键为 *C-x r m*
*** 列出保存的书签
   *bookmark-bmenu-list* 对应快捷键为 *C-x r l* ，它将打开一个*Bookmark List*的buffer同时
   列出所有保存的书签。
**** 书签列表*Bookmark List*
    在*Bookmark List*这个buffer里，有以下快捷键可以使用：
    - a 显示当前书签的标注信息;
    - A 在另一个buffer中显示所有书签的所有标注信息;
    - d 标记书签，以便用来删除 (x – 执行删除);
    - e 编辑当前书签的标注信息;
    - m 标记书签，以便用于进一步显示和其他操作 (v – 访问这个书签);
    - o 选中当前书签，并显示在另一个window中;
    - C-o 在另一个window中切换到当前这个书签;
    - r 重命名当前书签;
    - w 将当前书签的位置显示在minibuffer里。
*** 跳转到一个书签
   使用 *bookmark-jump* 函数，可以跳转到一个特定的书签，它绑定的快捷键为 *C-x r b* 。
   如果你的emacs中安装了[[https://github.com/emacs-helm/helm][helm]] 这个插件，你也可以使用 *helm-bookmarks* 这个命令
   来快速查找书签，并跳转到书签位置。
**** helm-bookmarks
    通过helm-bookmarks命令来查找并跳转书签如下图：
    [[./images/bookmark.png]]
**** 修改默认排序
    书签查找和跳转的时候，默认的书签排序是按字母排序的。如果想将最近访问的书签放在最前面，
    将下面代码添加到你的emacs配置文件中。
    #+NAME: 修改默认排序
    #+BEGIN_SRC emacs-lisp
(defadvice bookmark-jump (after bookmark-jump activate)
  (let ((latest (bookmark-get-bookmark bookmark)))
    (setq bookmark-alist (delq latest bookmark-alist))
    (add-to-list 'bookmark-alist latest)))
    #+END_SRC
*** 删除一个书签
   删除一个书签对应的命令为 *bookmark-delete* 。
*** 保存书签
   最新版本emacs（老版本的书签保存在 *~/.emacs.bmk* ），
   在退出的时候会自动保存书签。如果想手动保存书签的话，可以采用
   *bookmark-save* 这个函数命令。默认的情况，emacs会将书签保存在 *bookmark-default-file*
   变量对应的文件中。在我的机器中，对应的文件如下：
   #+NAME: 书签文件路径
   #+BEGIN_SRC emacs-lisp
ELISP> bookmark-default-file
"/Users/aborn/.emacs.d/.cache/bookmarks"
ELISP>
   #+END_SRC
*** 其他设置
   有一个变量 *bookmark-save-flag* 。如果这个变量的值为一个数值，它表示修改（或新增）
   多少次书签后，emacs会自动保存书签到磁盘。当这个变量的值被设置为1时，每次对bookmark的改
   动，emacs就会自动保存内容到磁盘相应位置（这样可以防止emacs突然crash时bookmark的丢失）。
   如果这个值设置为nil，表示emacs不会主动保存bookmark，除非用户手动调用
   *M-x bookmark-save* 。
*** bookmark+
   [[https://www.emacswiki.org/emacs/bookmark+.el][bookmark+]] 是对bookmark的一个扩展的包。它有更多的功能：
   1. 原始的bookmark只能对文件位置记录，bookmark+对孤立的buffer(没有关联文件的buffer)也能保存书签;
   2. 支持对书签进行打tag;
   3. 对文档的某个区域保存为书签，而不仅仅是某个位置;
   4. 记录了每个书签的访问次数，及最后一次的访问时间，可以基于它们排序;
   5. 多个书签可以有相同的名字;
   6. 可以对函数、变量等加书签。
   更多功能请参考: https://www.emacswiki.org/emacs/BookmarkPlus#Bookmark%2b
* dired 实践
** dired文件管理
  dired的全称为Directory Edit，即目录编辑，是一个非常老的模式。是Emacs下的一个文件管理神器!
  进入当前文件的dired文件管理，*M-x dired* 。
*** 常用命令
**** 光标移动命令
    + *n* 下移
    + *p* 上移
**** 文件操作
    + *C* 拷贝文件，dired-recursive-copies变量决定了拷贝的类型,一般为top
    + *D* 删除文件，类似的有一个 dired-recursive-deletes 变量可以控制递归删除
    + *R* 重命名或者移动文件
    + *D* 删除文件或者目录
    + *+* 创建目录
    + *Z* gzip压缩文件
    + *w* 复制文件名(C-u 则复制相对于dired当前目录的相对目录)
    + *A* 对文件进行正则表达式搜索，会在第一个匹配的地方停下，然后使用M-, 搜索下一个匹配。
**** 其他命令
    + *RET* 打开文件或者目录
    + *g*   刷新当前dired buffer
    + *k*   隐藏不想显示出来的文件
    + *q*   退出
*** 标记与操作
   dired可以对多个文件进行标记，然后进行批量操作。一个典型的是采用 *d* 对当前文件打上删除标记，
   然后使用 *x* 命令来删除所有标记的文件.
**** 标记操作命令
    + m 以星标记当前文件
    + * * 标记所有可执行文件
    + * @ 标记所有符号链接
    + * / 标记所有目录(不包括 . 和 .. )
    + * s 标记所有文件(不包括 . 和 .. )
    + * . 标记具有给定扩展名的文件
    + % m REGEXP <RET> 或 * % REGEXP <RET> 标记所有匹配到给定的正则表达式 的文件。
    + % g REGEXP <RET> 标记所有文件 内容 匹配到给定的正则表达式的文件。
**** 其他标记相关命令
    + u 去除当前行的标记
    + U 去除所有标记
*** 批量执行Shell命令
   在dired模式下，可以对标记的文件批量执行shell命令（如果没有标记文件，则对当前文件执行shell），
   运行命令 *dired-do-shell-command* (绑定的快捷键为 *!* )，相应的它有一个对应的异步操作
   的命令 *dired-do-async-shell-command* (绑定的快捷键为 *&* )。
*** dired的扩展
**** diredful
    [[https://github.com/thamer/diredful][diredful]] 可使得不同的文件显示不同的颜色,是一个非常好的扩展
**** dired-icon
    [[https://gitlab.com/xuhdev/dired-icon][dired-icon]] 根据文件类型显示相应icon
* magit 实践
** magit模式简介
  magit是emacs下版本管理的强大武器
** 常用命令
  + *magit-dispatch-popup* 命令分发器，在spacemacs里绑定到 *M-m g m*
  + *magit-diff* 相当于git diff, 当进入diff-buffer后按 /g/ 更新之
  + *magit-status* 相当于git status, 进入status-buffer后按s添加文件或文件夹到本地仓库
  + *magit-checkout* 切换分支
  + *magit-branch-and-checkout* 从当前分支切一个新的分支
** 分支操作
  常用的分支操作如下：
  + (magit-branch-delete) *b k* 删除一个或多个（本地）分支
  + (magit-branch-rename) *b r* 对当前Branch进行重命名
  + (magit-get-current-branch) 获取当前分支名
* 包管理
** Emacs的Package-Mode
  当通过*M-x list-package*命令打开一个*Package*的Buffer,它有如下命令:
  1. i 标识安装 （u 取消标识）
  2. x 执行安装操作
  3. d 标识删除 （x 执行删除操作）
  4. U 标识要更新的package
  5. ~ 标识所有废弃包
  6. M-x package-autoremove 删除那些无用的旧包
** 包列表
  1. elisp-slime-nav 写elisp代码时，可用于跳转到函数的定义
