#+TITLE: 基本数据类型
#+AUTHOR: aborn
#+DATE: 2016-12-21
#+EMAIL: aborn.jiang@gmail.com
#+LANGUAGE: zh
#+LATEX_HEADER: \usepackage{xeCJK}

#+SETUPFILE: ~/github/org-html-themes/setup/theme-readtheorg.setup

-----


* Lisp的数据类型
  Lisp的对象至少属于一种数据类型。Emacs里最基础的数据类型称之为原始类型（primitive type）,
  这些原始类型包括整型、浮点、cons、符号(symbol)、字符串、数组、哈希表（hash-table）、subr、
  二进制编码函数(byte-code function)，再加上一些特殊的类型，如buffer。同时，每种原始类型都
  有一个对应的函数去校验对象是否属于其类型。

* 列表
  列表是由零个或者多个元素组成的序列，列表中的每个元素都可由任意的对象组成。

** 关联列表alist (Association Lists)
   关联列表是一种特殊的列表，它的每个元素都是一个点对构成，如下示例:

   #+BEGIN_SRC emacs-lisp
   (setq alist-of-colors
      '((rose . red) (lily . white) (buttercup . yellow)))
   #+END_SRC

   关联列表可以用来记录key-value这样的map结构；对每个元素做car操作拿到key，做cdr操作即拿到
   相关系的value。

*** 关联列表操作
    + (assoc key alist) 获取列表第一个key所关联的值；下面是一个例子：

    #+BEGIN_SRC emacs-lisp
    ELISP> (assoc 'rose alist-of-colors)
    (rose . red)
    #+END_SRC

    注意：这里用得比较是equal函数，如想用eq函数，请采用(assq key alist)这个函数

    + (rassoc value alist) 获取列表第一个value为 *value* 所关联的值；
    + (assoc-default key alist) 获取列表中第一个key为 *key* 的value；

    #+BEGIN_SRC emacs-lisp
    ELISP> (assoc-default 'rose alist-of-colors)
    red
    #+END_SRC

** 属性列表plist (Property Lists)
   属性列表是由成对元素（paired elements）组成的列表，每个元素对关联着一个属性的名及其
   对应属性值。下面是一个例子：

   #+BEGIN_SRC emacs-lisp
    (pine cones numbers (1 2 3) color "blue")
   #+END_SRC

   这里pine关联其值为cons，numbers关联其值为(1 2 3)，一般每个元素对的关联值是由symbol类型
   组成的。

*** 属性列表的操作
    + (plist-get plist property) 返回属性列表中属性名为property的属性值:

    #+BEGIN_SRC emacs-lisp
    ELISP> (setq pl '(pine cones numbers (1 2 3) color "blue"))
    (pine cones numbers
          (1 2 3)
          color "blue")
    ELISP> (plist-get pl 'pine)
    cones
    ELISP> (plist-get pl 'numbers)
    (1 2 3)
    #+END_SRC

    + (plist-member plist property) 如果属性列表plist中含有属性property，则返回non-nil。
    + (plist-put plist property value) 保存属性property及值value的属性对

    #+BEGIN_SRC emacs-lisp
    (setq my-plist '(bar t foo 4))                    ;; => (bar t foo 4)
    (setq my-plist (plist-put my-plist 'foo 69))      ;; => (bar t foo 69)
    (setq my-plist (plist-put my-plist 'quux '(a)))   ;; => (bar t foo 69 quux (a))
    #+END_SRC

** 对列表进行排序
   对列表进行排序可以采用sort这个函数 *(sort list predicate)* 。不过这个函数是有副作用的，
   这个函数调用后会改变原有list的结构。第三个参数predicate传入的是一个比较函数，它接收两个参数。
   如果是想递增排序，当第一个参数小于第二个参数时返回non-nil，否则返回nil。注意这个sort函数
   对list的排序，始终保持car部分不变。下面是一个例子：

   #+BEGIN_SRC emacs-lisp
    ELISP> (setq nums '(1 3 2 6 5 4 0))
    (1 3 2 6 5 4 0)
    ELISP> (sort nums '<)
    (0 1 2 3 4 5 6)
    ELISP> nums
    (1 2 3 4 5 6)
   #+END_SRC

   注意这里的nums排序后，的car与原来list的car是一样的。所以一般采用重新赋值的方式
   *(setq nums (sort nums ’<))*
